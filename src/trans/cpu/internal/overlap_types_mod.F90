MODULE OVERLAP_TYPES_MOD
  USE LINKED_LIST_M, ONLY: LINKEDLIST
  USE PARKIND1,      ONLY: JPIM, JPRB
!  USE COMMON
  
  IMPLICIT NONE
  PRIVATE

    integer, public, parameter :: stat_waiting = 1
    integer, public, parameter :: stat_pending = 2
    integer, public, parameter :: stat_ready = 3

    TYPE, PUBLIC :: BATCH
     INTEGER(KIND=JPIM) :: STATUS
    INTEGER(KIND=JPIM) :: STAGE     
    INTEGER(KIND=JPIM) :: NBLK
    INTEGER(KIND=JPIM) :: NF_SCALARS_G
    INTEGER(KIND=JPIM) :: NF_UV
    INTEGER(KIND=JPIM) :: NF_SCALARS
    INTEGER(KIND=JPIM) :: NF_FS
    INTEGER(KIND=JPIM) :: NF_GP
    INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRGP(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPUV(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPSC(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NVSET(:)
    INTEGER(KIND=JPIM) :: IOFFGTF
    INTEGER(KIND=JPIM) :: NSENDCOUNT
    INTEGER(KIND=JPIM) :: NRECVCOUNT
    INTEGER(KIND=JPIM) :: NNSEND
    INTEGER(KIND=JPIM) :: NNRECV
    INTEGER(KIND=JPIM) :: MYOFFSEND
    INTEGER(KIND=JPIM) :: MYOFFRECV
    INTEGER(KIND=JPIM), ALLOCATABLE :: NSENDTOT(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NRECVTOT(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NSEND(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NRECV(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NINDEX(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NNDOFF(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: NGPTRSEND(:,:,:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: IRECV_FLD_END(:)
    INTEGER(KIND=JPIM) :: A2AREQ
  CONTAINS
    PROCEDURE :: START_COMM
    PROCEDURE :: COMM_COMPLETE
    PROCEDURE :: EXECUTE
  END TYPE BATCH

  INTERFACE BATCH
    MODULE PROCEDURE :: BATCH_CONSTRUCTOR
  END INTERFACE BATCH

  TYPE, PUBLIC, EXTENDS(LINKEDLIST) :: BATCHLIST
  CONTAINS
    PROCEDURE :: APPEND => APPEND_BATCH
  END TYPE BATCHLIST

CONTAINS

  ! -----------------------------------------------------------------------------
  ! Batch methods
  ! -----------------------------------------------------------------------------

  FUNCTION BATCH_CONSTRUCTOR(KBLK, KF_GP, KF_SCALARS_G, KF_UV_G, KVSETUV, KVSETSC, IOFFSEND, &
    &                        IOFFRECV, IOFFGTF, SENDCNTMAX, RECVCNTMAX) RESULT(THIS)
    USE SHUFFLE_MOD,     ONLY: SHUFFLE
    USE FIELD_SPLIT_MOD, ONLY: FIELD_SPLIT
    USE TPM_GEN,         ONLY: NPROMATR, NOUT
    USE TPM_DISTR,       ONLY: D, NPRTRNS, NPROC
    USE TPM_TRANS,       ONLY: NGPBLKS
    USE TRGTOL_MOD,      ONLY: TRGTOL_PROLOG
    USE MPL_MODULE,      ONLY: MPL_SEND, MPL_RECV, JP_NON_BLOCKING_STANDARD, JP_BLOCKING_STANDARD
    USE PE2SET_MOD,      ONLY: PE2SET

    INTEGER(KIND=JPIM),           INTENT(IN)    :: KBLK
    INTEGER(KIND=JPIM),           INTENT(IN)    :: KF_GP
    INTEGER(KIND=JPIM),           INTENT(IN)    :: KF_SCALARS_G
    INTEGER(KIND=JPIM),           INTENT(IN)    :: KF_UV_G
    ! Not actually optional!
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KVSETUV(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KVSETSC(:)
    INTEGER(KIND=JPIM),           INTENT(INOUT) :: IOFFSEND
    INTEGER(KIND=JPIM),           INTENT(INOUT) :: IOFFRECV
    INTEGER(KIND=JPIM),           INTENT(INOUT) :: IOFFGTF
    INTEGER(KIND=JPIM),           INTENT(IN)    :: SENDCNTMAX
    INTEGER(KIND=JPIM),           INTENT(IN)    :: RECVCNTMAX

    INTEGER(KIND=JPIM) :: NSTUV_G
    INTEGER(KIND=JPIM) :: NENUV_G
    INTEGER(KIND=JPIM) :: NF_UV_G
    INTEGER(KIND=JPIM) :: NSTSC_G
    INTEGER(KIND=JPIM) :: NENSC_G
    INTEGER(KIND=JPIM) :: NSTUV
    INTEGER(KIND=JPIM) :: NENUV
    INTEGER(KIND=JPIM) :: NSTSC
    INTEGER(KIND=JPIM) :: NENSC
    INTEGER(KIND=JPIM) :: NSHFUV_G(KF_GP)
    INTEGER(KIND=JPIM) :: NSHFSC_G(KF_GP)
    INTEGER(KIND=JPIM) :: NVSETUV(KF_GP)
    INTEGER(KIND=JPIM) :: NVSETSC(KF_GP)
    INTEGER(KIND=JPIM), ALLOCATABLE :: ISEND_FLD_END(:), IREQ_SEND(:)
    INTEGER(KIND=JPIM) :: ISETA, ISETB, ISETV, ISETW

    INTEGER :: JFLD, IST
    INTEGER(KIND=JPIM) :: INS, ISEND, INR, IRECV

    TYPE(BATCH) :: THIS

    THIS%STAGE = 1
    THIS%STATUS = STAT_PENDING
    THIS%NBLK = KBLK

    CALL SHUFFLE(KF_UV_G, KF_SCALARS_G, NSHFUV_G, NVSETUV, NSHFSC_G, &
      &          NVSETSC, KVSETUV, KVSETSC)

    CALL FIELD_SPLIT(KBLK, KF_GP, KF_UV_G, NVSETUV, NVSETSC, NSTUV_G, &
      &              NENUV_G, NF_UV_G, NSTSC_G, NENSC_G, &
      &              THIS%NF_SCALARS_G, NSTUV, NENUV, THIS%NF_UV, NSTSC, &
      &              NENSC, THIS%NF_SCALARS)

    THIS%NF_FS = 2*THIS%NF_UV + THIS%NF_SCALARS
    THIS%NF_GP = 2*NF_UV_G + THIS%NF_SCALARS_G

    ALLOCATE(THIS%NPTRGP(THIS%NF_GP))
    ALLOCATE(THIS%NPTRSPUV(NPROMATR))
    ALLOCATE(THIS%NPTRSPSC(NPROMATR))

    DO JFLD = 1, NF_UV_G
      THIS%NPTRGP(JFLD) = NSHFUV_G(NSTUV_G+JFLD-1)
      THIS%NPTRGP(JFLD+NF_UV_G) = KF_UV_G + NSHFUV_G(NSTUV_G+JFLD-1)
    ENDDO
    DO JFLD = 1, THIS%NF_SCALARS_G
      THIS%NPTRGP(JFLD+2*NF_UV_G) = 2*KF_UV_G + NSHFSC_G(NSTSC_G+JFLD-1)
    ENDDO
    DO JFLD = 1, THIS%NF_UV
      THIS%NPTRSPUV(JFLD) = NSTUV + JFLD - 1
    ENDDO
    DO JFLD = 1, THIS%NF_SCALARS
      THIS%NPTRSPSC(JFLD) = NSTSC + JFLD - 1
    ENDDO

    ! Compute this batch's offset into PGTF
    THIS%IOFFGTF = IOFFGTF
    IOFFGTF = IOFFGTF + THIS%NF_FS

    ALLOCATE(THIS%NVSET(THIS%NF_GP))
    IST = 1
    IF (NF_UV_G > 0) THEN
      THIS%NVSET(IST:IST+NF_UV_G-1) = NVSETUV(NSTUV_G:NENUV_G)
      IST = IST + NF_UV_G
      THIS%NVSET(IST:IST+NF_UV_G-1) = NVSETUV(NSTUV_G:NENUV_G)
      IST = IST + NF_UV_G
    ENDIF
    IF (THIS%NF_SCALARS_G > 0) THEN
      THIS%NVSET(IST:IST+THIS%NF_SCALARS_G-1) = NVSETSC(NSTSC_G:NENSC_G)
      IST = IST + THIS%NF_SCALARS_G
    ENDIF

    ALLOCATE(THIS%NSENDTOT(NPROC))
    ALLOCATE(THIS%NRECVTOT(NPROC))
    ALLOCATE(THIS%NSEND(NPROC))
    ALLOCATE(THIS%NRECV(NPROC))
    ALLOCATE(THIS%NINDEX(D%NLENGTF))
    ALLOCATE(THIS%NNDOFF(NPROC))
    ALLOCATE(THIS%NGPTRSEND(2,NGPBLKS,NPRTRNS))
    CALL TRGTOL_PROLOG(THIS%NF_FS, THIS%NF_GP, THIS%NVSET, THIS%NSENDCOUNT, THIS%NRECVCOUNT, &
      &                THIS%NNSEND, THIS%NNRECV, THIS%NSENDTOT, THIS%NRECVTOT, THIS%NSEND, &
      &                THIS%NRECV, THIS%NINDEX, THIS%NNDOFF, THIS%NGPTRSEND)

    ! Compute this batch's offsets into ZCOMBUFS and ZCOMBUFR
    THIS%MYOFFSEND = IOFFSEND
    IOFFSEND = IOFFSEND + THIS%NSENDCOUNT
    THIS%MYOFFRECV = IOFFRECV
    IOFFRECV = IOFFRECV + THIS%NRECVCOUNT
    
!    ALLOCATE(ISEND_FLD_END(THIS%NNSEND),IREQ_SEND(THIS%NNSEND))
!    ALLOCATE(THIS%IRECV_FLD_END(THIS%NNRECV))

    ! Loop over all tasks we are sending to
!    DO INS = 1, THIS%NNSEND
      ! Determine V-set of this task
!      CALL PE2SET(THIS%NSEND(INS), ISETA, ISETB, ISETW, ISETV)

      ! Determine how many fields this task should expect
!      ISEND_FLD_END(INS) = COUNT(THIS%NVSET(:) == ISETV .OR. THIS%NVSET(:) == -1)

      ! Send that value to that task
!      CALL MPL_SEND(ISEND_FLD_END(INS), THIS%NSEND(INS), KBLK, KMP_TYPE=JP_NON_BLOCKING_STANDARD, &
!        &           KREQUEST=IREQ_SEND(INS))
!    ENDDO
    
    ! Also receive the corresponding values from other tasks
!    DO INR = 1, THIS%NNRECV
!      CALL MPL_RECV(THIS%IRECV_FLD_END(INR), THIS%NRECV(INR), KBLK, KMP_TYPE=JP_BLOCKING_STANDARD)
!    ENDDO
  END FUNCTION BATCH_CONSTRUCTOR

  SUBROUTINE START_COMM(THIS, PGP, IREQ_RECV,PGTF,PCOMBUFS,PCOMBUFR)
    USE TRGTOL_MOD, ONLY: TRGTOL_COMM_SEND
    USE LTDIR_CTL_MOD, ONLY: LTDIR_CTL_SEND
    
    CLASS(BATCH),              INTENT(INOUT) :: THIS
    REAL(KIND=JPRB), OPTIONAL, INTENT(IN)    :: PGP(:,:,:)
    INTEGER(KIND=JPIM),        INTENT(INOUT) :: IREQ_RECV(:)
    REAL(KIND=JPRB),           INTENT(OUT)   :: PGTF(:,:)
    REAL(KIND=JPRB),           INTENT(INOUT) :: PCOMBUFR(:,:)
    REAL(KIND=JPRB),           INTENT(INOUT) :: PCOMBUFS(:,:)

    SELECT CASE(THIS%STAGE)

       CASE (1)
    
       CALL TRGTOL_COMM_SEND(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:), &
      &                   PCOMBUFS, &
      &                   PCOMBUFR, &
      &                   THIS%MYOFFSEND, THIS%MYOFFRECV, &
      &                   THIS%NF_FS, THIS%NF_GP, THIS%NF_SCALARS_G, THIS%NVSET, THIS%NSENDCOUNT, &
      &                   THIS%NRECVCOUNT, THIS%NNSEND, THIS%NNRECV, THIS%NSENDTOT, &
      &                   THIS%NRECVTOT, THIS%NSEND, THIS%NRECV, THIS%NINDEX, THIS%NNDOFF, &
      &                   THIS%NGPTRSEND, IREQ_RECV, &
      &                   THIS%NPTRGP, PGP)

       CASE (2)

          write(11,*) 'nf_fs=',this%nf_fs
          flush(11)
          
       CALL LTDIR_CTL_SEND(THIS%IOFFGTF,THIS%NF_FS,THIS%A2AREQ)
       
    END SELECT

    THIS%STATUS = STAT_WAITING
    
  END SUBROUTINE START_COMM

  FUNCTION COMM_COMPLETE(THIS, IREQ_RECV)
    USE MPI,     ONLY: MPI_STATUS_IGNORE, MPI_TESTALL,MPI_STATUSES_IGNORE

    CLASS(BATCH),       INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM), INTENT(INOUT) :: IREQ_RECV(:)

    LOGICAL :: COMM_COMPLETE
!    INTEGER(KIND=JPIM), ALLOCATABLE :: ISTATS(:,:)
    INTEGER(KIND=JPIM) :: IERROR

!    ALLOCATE(ISTATS(MPI_STATUS_SIZE,THIS%NNRECV))

    COMM_COMPLETE = .FALSE.
!    DO WHILE(.NOT. COMM_COMPLETE)
!      CALL MPI_TESTALL(THIS%NNRECV, IREQ_RECV(1:THIS%NNRECV), COMM_COMPLETE, ISTATS, IERROR)
    
    SELECT CASE(THIS%STAGE)

       CASE (1)

       CALL MPI_TESTALL(THIS%NNRECV, IREQ_RECV(1:THIS%NNRECV), COMM_COMPLETE, &
            &  MPI_STATUSES_IGNORE, IERROR)

       CASE (2)

       CALL MPI_TEST(THIS%A2AREQ,COMM_COMPLETE,MPI_STATUS_IGNORE,IERROR)

    END SELECT
    
!    ENDDO
  END FUNCTION COMM_COMPLETE

  SUBROUTINE EXECUTE(THIS, PGTF, IREQ_RECV, PCOMBUFR, PSPVOR, PSPDIV, PSPSCALAR)
    USE TRGTOL_MOD,    ONLY: TRGTOL_COMM_RECV
    USE FTDIR_CTL_MOD, ONLY: FTDIR_CTL_COMP
    USE LTDIR_CTL_MOD, ONLY: LTDIR_CTL_SEND,LTDIR_CTL_COMP
    USE TPM_TRANS,       ONLY: FOUBUF_IN
    USE TPM_DISTR, ONLY: D
    
    CLASS(BATCH),              INTENT(INOUT) :: THIS
    REAL(KIND=JPRB),           INTENT(INOUT) :: PGTF(:,:)
    INTEGER(KIND=JPIM),        INTENT(INOUT) :: IREQ_RECV(:)
    REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPVOR(:,:)
    REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPDIV(:,:)
    REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPSCALAR(:,:)
    REAL(KIND=JPRB),           INTENT(INOUT) :: PCOMBUFR(:,:)
    INTEGER(KIND=JPIM) :: IST,IEN
    
    SELECT CASE (THIS%STAGE)
    CASE (1)

       CALL TRGTOL_COMM_RECV(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:), &
        &                 PCOMBUFR, THIS%MYOFFRECV, &
        &                 THIS%IRECV_FLD_END, &
        &                 THIS%NF_FS, THIS%NRECVCOUNT, THIS%NNRECV, THIS%NRECVTOT, THIS%NRECV, &
        &                 THIS%NINDEX, THIS%NNDOFF, IREQ_RECV)
       IST = 1+D%NLENGT0B*2*(THIS%IOFFGTF-1)
       IEN = IST + D%NLENGT0B*2*THIS%NF_FS-1
       CALL FTDIR_CTL_COMP(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:),  &
         &     FOUBUF_IN(IST:IEN),THIS%NF_FS)

    CASE (2)

       CALL LTDIR_CTL_COMP(THIS%IOFFGTF,THIS%NF_FS, THIS%NF_UV, THIS%NF_SCALARS,THIS%A2AREQ, &
         &     PSPVOR=PSPVOR, PSPDIV=PSPDIV, PSPSCALAR=PSPSCALAR, KFLDPTRUV=THIS%NPTRSPUV, &
         &     KFLDPTRSC=THIS%NPTRSPSC)

    END SELECT

    THIS%STAGE = THIS%STAGE + 1
    THIS%STATUS = STAT_PENDING
    
  END SUBROUTINE EXECUTE

  ! -----------------------------------------------------------------------------
  ! BATCHLIST methods
  ! -----------------------------------------------------------------------------

  ! Add a value to the list at the tail
  SUBROUTINE APPEND_BATCH(THIS, VALUE)
    USE LINKED_LIST_M, ONLY: LINKEDLISTNODE

    CLASS(BATCHLIST), INTENT(INOUT) :: THIS
    CLASS(*), INTENT(IN), TARGET    :: VALUE

    TYPE(LINKEDLISTNODE), POINTER :: NODE_PTR, NEXT_PTR, CURRENT_PTR

    ! Create a new node and set the value
    ALLOCATE(NODE_PTR)
    ALLOCATE(NODE_PTR%VALUE, SOURCE=VALUE)
    NODE_PTR%NEXT => NULL()
    THIS%SIZE = THIS%SIZE + 1

    IF (.NOT. ASSOCIATED(THIS%HEAD))THEN
      THIS%HEAD => NODE_PTR
      THIS%TAIL => NODE_PTR
    ELSE
      THIS%TAIL%NEXT => NODE_PTR
      NODE_PTR%PREV  => THIS%TAIL
      THIS%TAIL      => NODE_PTR
    END IF
  END SUBROUTINE APPEND_BATCH

END MODULE OVERLAP_TYPES_MOD
