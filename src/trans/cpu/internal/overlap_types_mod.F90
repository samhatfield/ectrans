MODULE OVERLAP_TYPES_MOD
  USE LINKED_LIST_M, ONLY: LINKEDLIST
  USE PARKIND1,      ONLY: JPIM, JPRB

  IMPLICIT NONE
  PRIVATE

  TYPE, PUBLIC :: BATCH
      INTEGER(KIND=JPIM) :: NBLK
      INTEGER(KIND=JPIM) :: NSTUV_G
      INTEGER(KIND=JPIM) :: NENUV_G
      INTEGER(KIND=JPIM) :: NF_UV_G
      INTEGER(KIND=JPIM) :: NSTSC_G
      INTEGER(KIND=JPIM) :: NENSC_G
      INTEGER(KIND=JPIM) :: NF_SCALARS_G
      INTEGER(KIND=JPIM) :: NSTUV
      INTEGER(KIND=JPIM) :: NENUV
      INTEGER(KIND=JPIM) :: NF_UV
      INTEGER(KIND=JPIM) :: NSTSC
      INTEGER(KIND=JPIM) :: NENSC
      INTEGER(KIND=JPIM) :: NF_SCALARS
      INTEGER(KIND=JPIM) :: NF_FS
      INTEGER(KIND=JPIM) :: NF_GP
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSHFUV_G(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSHFSC_G(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NVSETUV(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NVSETSC(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRGP(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPUV(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPSC(:)
  CONTAINS
      PROCEDURE :: START_COMM
      PROCEDURE :: COMM_COMPLETE
      PROCEDURE :: FINISH_COMM
  END TYPE BATCH

  INTERFACE BATCH
      MODULE PROCEDURE :: BATCH_CONSTRUCTOR
  END INTERFACE BATCH

  TYPE, PUBLIC, EXTENDS(LINKEDLIST) :: BATCHLIST
  CONTAINS
      PROCEDURE :: APPEND => APPEND_BATCH
  END TYPE BATCHLIST

CONTAINS

    ! -----------------------------------------------------------------------------
    ! Batch methods
    ! -----------------------------------------------------------------------------

    FUNCTION BATCH_CONSTRUCTOR(KBLK, KF_GP, KF_SCALARS_G, KF_UV_G, KVSETUV, KVSETSC) RESULT(THIS)
        USE SHUFFLE_MOD,     ONLY: SHUFFLE
        USE FIELD_SPLIT_MOD, ONLY: FIELD_SPLIT
        USE TPM_GEN,         ONLY: NPROMATR, NOUT

        INTEGER(KIND=JPIM), INTENT(IN) :: KBLK
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_GP
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_SCALARS_G
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_UV_G
        ! Not actually optional!
        INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: KVSETUV(:)
        INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: KVSETSC(:)

        INTEGER :: JFLD
        
        TYPE(BATCH) :: THIS

        THIS%NBLK = KBLK

        ALLOCATE(THIS%NSHFUV_G(KF_GP))
        ALLOCATE(THIS%NSHFSC_G(KF_GP))
        ALLOCATE(THIS%NVSETUV(KF_GP))
        ALLOCATE(THIS%NVSETSC(KF_GP))

        CALL SHUFFLE(KF_UV_G, KF_SCALARS_G, THIS%NSHFUV_G, THIS%NVSETUV, THIS%NSHFSC_G, &
          &          THIS%NVSETSC, KVSETUV, KVSETSC)

        CALL FIELD_SPLIT(KBLK, KF_GP, KF_UV_G, THIS%NVSETUV, THIS%NVSETSC, THIS%NSTUV_G, &
          &              THIS%NENUV_G, THIS%NF_UV_G, THIS%NSTSC_G, THIS%NENSC_G, &
          &              THIS%NF_SCALARS_G, THIS%NSTUV, THIS%NENUV, THIS%NF_UV, THIS%NSTSC, &
          &              THIS%NENSC, THIS%NF_SCALARS)

        THIS%NF_FS = 2*THIS%NF_UV + THIS%NF_SCALARS
        THIS%NF_GP = 2*THIS%NF_UV_G + THIS%NF_SCALARS_G

        WRITE(NOUT,*) "Batch", KBLK, "NF_UV_G", THIS%NF_UV_G, "NF_SCALARS_G", THIS%NF_SCALARS_G
        WRITE(NOUT,*) "Batch", KBLK, "NF_FS", THIS%NF_FS, "NF_GP", THIS%NF_GP

        ALLOCATE(THIS%NPTRGP(THIS%NF_GP))
        ALLOCATE(THIS%NPTRSPUV(NPROMATR))
        ALLOCATE(THIS%NPTRSPSC(NPROMATR))

        DO JFLD = 1, THIS%NF_UV_G
          THIS%NPTRGP(JFLD) = THIS%NSHFUV_G(THIS%NSTUV_G+JFLD-1)
          THIS%NPTRGP(JFLD+THIS%NF_UV_G) = KF_UV_G + THIS%NSHFUV_G(THIS%NSTUV_G+JFLD-1)
        ENDDO
        DO JFLD = 1, THIS%NF_SCALARS_G
          THIS%NPTRGP(JFLD+2*THIS%NF_UV_G) = 2*KF_UV_G + THIS%NSHFSC_G(THIS%NSTSC_G+JFLD-1)
        ENDDO
        DO JFLD = 1, THIS%NF_UV
          THIS%NPTRSPUV(JFLD) = THIS%NSTUV + JFLD - 1
        ENDDO
        DO JFLD = 1, THIS%NF_SCALARS
          THIS%NPTRSPSC(JFLD) = THIS%NSTSC + JFLD - 1
        ENDDO

    END FUNCTION BATCH_CONSTRUCTOR

    SUBROUTINE START_COMM(THIS, PGP)
        USE FTDIR_CTL_MOD, ONLY: FTDIR_CTL_COMM_SEND

        CLASS(BATCH),              INTENT(INOUT) :: THIS
        REAL(KIND=JPRB), OPTIONAL, INTENT(IN)    :: PGP(:,:,:)


        IF (THIS%NF_UV_G > 0 .AND. THIS%NF_SCALARS_G > 0) THEN
          CALL FTDIR_CTL_COMM_SEND(THIS%NF_UV_G, THIS%NF_SCALARS_G, THIS%NF_GP, THIS%NF_FS, &
            &                      KVSETUV=THIS%NVSETUV(THIS%NSTUV_G:THIS%NENUV_G), &
            &                      KVSETSC=THIS%NVSETSC(THIS%NSTSC_G:THIS%NENSC_G), &
            &                      KPTRGP=THIS%NPTRGP, PGP=PGP)
        ELSEIF (THIS%NF_UV_G > 0) THEN
          CALL FTDIR_CTL_COMM_SEND(THIS%NF_UV_G, THIS%NF_SCALARS_G, THIS%NF_GP, THIS%NF_FS, &
            &                      KVSETUV=THIS%NVSETUV(THIS%NSTUV_G:THIS%NENUV_G), &
            &                      KPTRGP=THIS%NPTRGP, PGP=PGP)
        ELSEIF (THIS%NF_SCALARS_G > 0) THEN
          CALL FTDIR_CTL_COMM_SEND(THIS%NF_UV_G, THIS%NF_SCALARS_G, THIS%NF_GP, THIS%NF_FS, &
            &                      KVSETSC=THIS%NVSETSC(THIS%NSTSC_G:THIS%NENSC_G), &
            &                      KPTRGP=THIS%NPTRGP, PGP=PGP)
        ENDIF
    END SUBROUTINE START_COMM

    FUNCTION COMM_COMPLETE(THIS)
      USE TRGTOL_MOD, ONLY: TRGTOL_COMM_TEST

      CLASS(BATCH), INTENT(INOUT) :: THIS

      LOGICAL :: COMM_COMPLETE

      COMM_COMPLETE = TRGTOL_COMM_TEST()
    END FUNCTION COMM_COMPLETE

    SUBROUTINE FINISH_COMM(THIS, PSPVOR, PSPDIV, PSPSCALAR)
      USE FTDIR_CTL_MOD, ONLY: FTDIR_CTL_COMP
      USE LTDIR_CTL_MOD, ONLY: LTDIR_CTL

      CLASS(BATCH), INTENT(INOUT) :: THIS
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPVOR(:,:)
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPDIV(:,:)
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPSCALAR(:,:)

      CALL FTDIR_CTL_COMP(THIS%NF_FS)
      CALL LTDIR_CTL(THIS%NF_FS, THIS%NF_UV, THIS%NF_SCALARS, PSPVOR=PSPVOR, PSPDIV=PSPDIV, &
        &            PSPSCALAR=PSPSCALAR, KFLDPTRUV=THIS%NPTRSPUV, KFLDPTRSC=THIS%NPTRSPSC)
    END SUBROUTINE FINISH_COMM

    ! -----------------------------------------------------------------------------
    ! BATCHLIST methods
    ! -----------------------------------------------------------------------------

    ! Add a value to the list at the tail
    SUBROUTINE APPEND_BATCH(THIS, VALUE)
      USE LINKED_LIST_M, ONLY: LINKEDLISTNODE

      CLASS(BATCHLIST), INTENT(INOUT) :: THIS
      CLASS(*), INTENT(IN), TARGET    :: VALUE

      TYPE(LINKEDLISTNODE), POINTER :: NODE_PTR, NEXT_PTR, CURRENT_PTR

      ! Create a new node and set the value
      ALLOCATE(NODE_PTR)
      ALLOCATE(NODE_PTR%VALUE, SOURCE=VALUE)
      NODE_PTR%NEXT => NULL()
      THIS%SIZE = THIS%SIZE + 1

      IF (.NOT. ASSOCIATED(THIS%HEAD)) THEN
         THIS%HEAD => NODE_PTR
         THIS%TAIL => NODE_PTR
      ELSE
         THIS%TAIL%NEXT => NODE_PTR
         NODE_PTR%PREV  => THIS%TAIL
         THIS%TAIL      => NODE_PTR
      END IF

  END SUBROUTINE APPEND_BATCH

END MODULE OVERLAP_TYPES_MOD
